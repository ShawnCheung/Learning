# 关键字库函数
> 第四章主要讲解关键字和库函数相关的内容，重点是对比功能上相似的一些关键字、库函数的区别，或者是名称上相似的关键字、库函数的区别，还对对一些关键字的用法进行讲解。

<div id="head"></div><br>

# 目录
[sizeof 和 strlen 的区别](#diff_sizeof_strlen)<br>
[lambda 表达式（匿名函数）的具体应用和使用场景](#lambda)<br>
[explicit 的作用（如何避免编译器进行隐式类型转换）](#explicit)<br>
[C 和 C++ static 的区别](#diff_static_c_cpp)<br>
[static 的作用](#use_static)<br>
[static 在类中使用的注意事项（定义、初始化和使用）](#attention_static)<br>
[static 全局变量和普通全局变量的异同](#static_global)<br>
[const 作用及用法](#const)<br>
[define 和 const 的区别](#diff_define_const)<br>
[define 和 typedef 的区别](#diff_define_typedef)<br>
[用宏实现比较大小，以及两个数中的最小值](#macro_cmp)<br>
[inline 作用及使用方法](#inline_func)<br>
[inline 函数工作原理](#inline_principle)<br>
[宏定义（define）和内联函数（inline）的区别](#diff_define_inline)<br>
[new 的作用？](#new_func)<br>
[new 和 malloc 如何判断是否申请到内存？](#new_malloc)<br>
[delete 实现原理？delete 和 delete[] 的区别？](#delete)<br>
[new 和 malloc 的区别，delete 和 free 的区别](#new_delete_malloc_free)<br>
[malloc 的原理？malloc 的底层实现？](#malloc)<br>
[C 和 C++ struct 的区别？](#struct)<br>
[为什么有了 class 还保留 struct？](#struct_class)<br>
[struct 和 union 的区别](#diff_struct_union)<br>
[class 和 struct 的异同](#diff_class_struct)<br>
[volatile 的作用？是否具有原子性，对编译器有什么影响？](#volatile)<br>
[什么情况下一定要用 volatile， 能否和 const 一起使用？](#volatile_const)<br>
[返回函数中静态变量的地址会发生什么？](#return_static)<br>
[extern C 的作用？](#extern)<br>
[sizeof(1==1) 在 C 和 C++ 中分别是什么结果？](#res_sizeof_c_cpp)<br>
[memcpy 函数的底层原理？](#memcpy)<br>
[strcpy 函数有什么缺陷？](#strcpy)<br>
[auto 类型推导的原理](#auto)<br>

<div id="diff_sizeof_strlen"></div><br>

## sizeof 和 strlen 的区别
> 1. strlen 是头文件 \<cstring> 中的函数，sizeof 是 C++ 中的运算符。
>
> 2. strlen 测量的是字符串的实际长度（其源代码如下），以 \0 结束。而 sizeof 测量的是字符数组的分配大小。<br>
> strlen源代码：
>    ```C++
>    size_t strlen(const char *str) {
>        size_t length = 0;
>        while (*str++)
>            ++length;
>        return length;
>    }
>    ```
>
>       举例：
>    ```C++
>    #include <iostream>
>    #include <cstring>
>
>    using namespace std;
>
>    int main()
>    {
>        char arr[10] = "hello";
>        cout << strlen(arr) << endl; // 5
>        cout << sizeof(arr) << endl; // 10
>        return 0;
>    }
>    ```
> 3. 若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。
>    ```C++
>    #include <iostream>
>    #include <cstring>
>
>    using namespace std;
>
>    void size_of(char arr[])
>    {
>        cout << sizeof(arr) << endl; // warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' .
>        cout << strlen(arr) << endl; 
>    }
>
>    int main()
>    {
>        char arr[20] = "hello";
>        size_of(arr); 
>        return 0;
>    }
>    /*
>    输出结果：
>    8
>    5
>    */
>    ```
> 4. strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在编译时，计算长度；
>
> 5. sizeof 的参数可以是类型，也可以是变量；strlen 的参数必须是 char* 类型的变量。


[返回目录](#head)
<div id="lambda"></div><br>

## lambda 表达式（匿名函数）的具体应用和使用场景
lambda 表达式的定义形式如下：
```C++
[capture list] (parameter list) -> reurn type
{
   function body
}
```
其中：
* capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&]、值捕获方式 [=]。
* return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。

举例：<br>
lambda 表达式常搭配排序算法使用。
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    vector<int> arr = {3, 4, 76, 12, 54, 90, 34};
    sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; }); // 降序排序
    for (auto a : arr)
    {
        cout << a << " ";
    }
    return 0;
}
/*
运行结果：90 76 54 34 12 4 3
*/
```
[返回目录](#head)
<div id="explicit"></div><br>

## explicit 的作用（如何避免编译器进行隐式类型转换）
作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。

隐式转换：

```C++
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    A(int tmp)
    {
        var = tmp;
    }
};
int main()
{
    A ex = 10; // 发生了隐式转换
    return 0;
}
```
上述代码中，A ex = 10; 在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：

为了避免隐式转换，可用 explicit 关键字进行声明：
```C++
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    explicit A(int tmp)
    {
        var = tmp;
        cout << var << endl;
    }
};
int main()
{
    A ex(100);
    A ex1 = 10; // error: conversion from 'int' to non-scalar type 'A' requested
    return 0;
}
```
[返回目录](#head)
<div id="diff_static_c_cpp"></div><br>

## C 和 C++ static 的区别
* 在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数
* 在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。

[返回目录](#head)
<div id="use_static"></div><br>

## static 的作用
作用：<br>
static 定义静态变量，静态函数。

* 保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。
    ```C++
    #include <iostream>
    using namespace std;

    int fun(){
        static int var = 1; // var 只在第一次进入这个函数的时初始化
        var += 1;
        return var;
    }
    
    int main()
    {
        for(int i = 0; i < 10; ++i)
            cout << fun() << " "; // 2 3 4 5 6 7 8 9 10 11
        return 0;
    }
    ```
* 隐藏：static 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）

* static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。
    ```C++
    #include<iostream>
    using namespace std;

    class A
    {
    private:
        int var;
        static int s_var; // 静态成员变量
    public:
        void show()
        {
            cout << s_var++ << endl;
        }
        static void s_show()
        {
            cout << s_var << endl;
            // cout << var << endl; // error: invalid use of member 'A::a' in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var
            // show();  // error: cannot call member function 'void A::show()' without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()
        }
    };
    int A::s_var = 1;  // 静态成员变量在类外进行初始化赋值，默认初始化为 0

    int main()
    {
        
        // cout << A::sa << endl;    // error: 'int A::sa' is private within this context
        A ex;
        ex.show();
        A::s_show();
    }
    ```
[返回目录](#head)
<div id="attention_static"></div><br>

## static 在类中使用的注意事项（定义、初始化和使用）
**static 静态成员变量：**

1. 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和private、public、protected 访问规则。
2. 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。
3. 静态成员变量可以作为成员函数的参数，而普通成员变量不可以。
    ```C++
    #include <iostream>
    using namespace std;

    class A
    {
    public:
        static int s_var;
        int var;
        void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数
        void fun2(int i = var);   //  error: invalid use of non-static data member 'A::var'
    };
    int main()
    {
        return 0;
    }
    ```
4. 静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。
    ```C++
    #include <iostream>
    using namespace std;

    class A
    {
    public:
        static A s_var; // 正确，静态数据成员
        A var;          // error: field 'var' has incomplete type 'A'
        A *p;           // 正确，指针
        A &var1;        // 正确，引用
    };

    int main()
    {
        return 0;
    }
    ```

**static 静态成员函数：**

1. 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数。
2. 静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。

[返回目录](#head)
<div id="static_global"></div><br>

## static 全局变量和普通全局变量的异同

[返回目录](#head)
<div id="const"></div><br>

## const 作用及用法

[返回目录](#head)
<div id="diff_define_const"></div><br>

## define 和 const 的区别

[返回目录](#head)
<div id="diff_define_typedef"></div><br>

## define 和 typedef 的区别

[返回目录](#head)
<div id="macro_cmp"></div><br>

## 用宏实现比较大小，以及两个数中的最小值

[返回目录](#head)
<div id="inline_func"></div><br>

## inline 作用及使用方法

[返回目录](#head)
<div id="inline_principle"></div><br>

## inline 函数工作原理

[返回目录](#head)
<div id="diff_define_inline"></div><br>

## 宏定义（define）和内联函数（inline）的区别

[返回目录](#head)
<div id="new_func"></div><br>

## new 的作用？

[返回目录](#head)
<div id="new_malloc"></div><br>

## new 和 malloc 如何判断是否申请到内存？

[返回目录](#head)
<div id="delete"></div><br>

## delete 实现原理？delete 和 delete[] 的区别？

[返回目录](#head)
<div id="new_delete_malloc_free"></div><br>

## new 和 malloc 的区别，delete 和 free 的区别

[返回目录](#head)
<div id="malloc"></div><br>

## malloc 的原理？malloc 的底层实现？

[返回目录](#head)
<div id="struct"></div><br>

## C 和 C++ struct 的区别？

[返回目录](#head)
<div id="struct_class"></div><br>

## 为什么有了 class 还保留 struct？

[返回目录](#head)
<div id="diff_struct_union"></div><br>

## struct 和 union 的区别

[返回目录](#head)
<div id="diff_class_struct"></div><br>

## class 和 struct 的异同

[返回目录](#head)
<div id="volatile"></div><br>

## volatile 的作用？是否具有原子性，对编译器有什么影响？

[返回目录](#head)
<div id="volatile_const"></div><br>

## 什么情况下一定要用 volatile， 能否和 const 一起使用？

[返回目录](#head)
<div id="return_static"></div><br>

## 返回函数中静态变量的地址会发生什么？

[返回目录](#head)
<div id="extern"></div><br>

## extern C 的作用？

[返回目录](#head)
<div id="res_sizeof_c_cpp"></div><br>

## sizeof(1==1) 在 C 和 C++ 中分别是什么结果？

[返回目录](#head)
<div id="memcpy"></div><br>

## memcpy 函数的底层原理？

[返回目录](#head)
<div id="strcpy"></div><br>

## strcpy 函数有什么缺陷？

[返回目录](#head)
<div id="auto"></div><br>

## auto 类型推导的原理

[返回目录](#head)

