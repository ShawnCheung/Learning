# 语言特性相关
第六章重点介绍和 C++ 语言特性相关的知识点，涉及到指针、引用、强制类型转换等。在本章中也增加了设计模式相关知识点，重点对单例模式进行介绍，包括其实现思想，应用场景，代码实现等。

<div id="head"></div><br>

# 目录
[左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？](#diff_left_right)<br>
[std::move() 函数的实现原理](#move)<br>
[什么是指针？指针的大小及用法？](#ptr)<br>
[什么是野指针和悬空指针？](#wild_ptr_hang_ptr)<br>
[C++ 11 nullptr 比 NULL 优势](#nullptr)<br>
[指针和引用的区别？](#ptr_quote)<br>
[常量指针和指针常量的区别](#const)<br>
[函数指针和指针函数的区别](#func_ptr_func)<br>
[强制类型转换有哪几种？](#force)<br>
[如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？](#struct_equal)<br>
[参数传递时，值传递、引用传递、指针传递的区别？](#parameter)<br>
[什么是模板？如何实现？](#template)<br>
[函数模板和类模板的区别？](#diff_func_class_template)<br>
[什么是可变参数模板？](#variable_template)<br>
[什么是模板特化？为什么特化？](#template_specialty)<br>
[include " " 和 <> 的区别](#include)<br>
[switch 的 case 里为何不能定义变量](#switch)<br>
[迭代器的作用？](#iterator)<br>
[泛型编程如何实现？](#generic)<br>
[什么是类型萃取？](#type_extraction)<br>

<div id="diff_left_right"></div><br>

## 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？
左值：指表达式结束后依然存在的持久对象。

右值：表达式结束就不再存在的临时对象。

左值和右值的区别：左值持久，右值短暂

右值引用和左值引用的区别：

* 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。
* 右值引用必须绑定到右值的引用，通过 && 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。
std::move 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。

```C++
#include <iostream>
using namespace std;

void fun1(int& tmp) 
{ 
  cout << "fun1(int& tmp):" << tmp << endl; 
} 

void fun2(int&& tmp) 
{ 
  cout << "fun2(int&& tmp)" << tmp << endl; 
} 

int main() 
{ 
  int var = 11; 
  fun1(12); // error: cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int'
  fun1(var);
  fun2(1); 
}
```

[返回目录](#head)<br>

<div id="move"></div><br>

## std::move() 函数的实现原理
std::move() 函数原型：

```C++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
	return static_cast<typename remove_reference<T>::type &&>(t);
}
```
说明：引用折叠原理

右值传递给上述函数的形参 T&& 依然是右值，即 T&& && 相当于 T&&。
左值传递给上述函数的形参 T&& 依然是左值，即 T&& & 相当于 T&。
小结：通过引用折叠原理可以知道，move() 函数的形参既可以是左值也可以是右值。

remove_reference 具体实现：

```C++

//原始的，最通用的版本
template <typename T> struct remove_reference{
    typedef T type;  //定义 T 的类型别名为 type
};
 
//部分版本特例化，将用于左值引用和右值引用
template <class T> struct remove_reference<T&> //左值引用
{ typedef T type; }
 
template <class T> struct remove_reference<T&&> //右值引用
{ typedef T type; }   
  
//举例如下,下列定义的a、b、c三个变量都是int类型
int i;
remove_refrence<decltype(42)>::type a;             //使用原版本，
remove_refrence<decltype(i)>::type  b;             //左值引用特例版本
remove_refrence<decltype(std::move(i))>::type  b;  //右值引用特例版本 
```
举例：

```C++
int var = 10; 
```
转化过程：
1. std::move(var) => std::move(int&& &) => 折叠后 std::move(int&)

2. 此时：T 的类型为 int&，typename remove_reference<T>::type 为 int，这里使用 remove_reference 的左值引用的特例化版本

3. 通过 static_cast 将 int& 强制转换为 int&&

整个std::move被实例化如下
```C++
string&& move(int& t) 
{
    return static_cast<int&&>(t); 
}
```
总结：
std::move() 实现原理：

利用引用折叠原理将右值经过 T&& 传递类型保持不变还是右值，而左值经过 T&& 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；
然后通过 remove_refrence 移除引用，得到具体的类型 T；
最后通过 static_cast<> 进行强制类型转换，返回 T&& 右值引用。

[返回目录](#head)<br>

<div id="ptr"></div><br>

## 什么是指针？指针的大小及用法？
**指针：** 指向另外一种类型的复合类型。

**指针的大小：** 在 64 位计算机中，指针占 8 个字节空间。

```C++
#include<iostream>

using namespace std;

int main(){
    int *p = nullptr;
    cout << sizeof(p) << endl; // 8

    char *p1 = nullptr;
    cout << sizeof(p1) << endl; // 8
    return 0;
}
```
**指针的用法：**
1. 指向普通对象的指针
```C++
#include <iostream>

using namespace std;

class A
{
};

int main()
{
    A *p = new A();
    return 0;
}
```
2. 指向常量对象的指针：常量指针
```C++
#include <iostream>
using namespace std;

int main(void)
{
    const int c_var = 10;
    const int * p = &c_var;
    cout << *p << endl;
    return 0;
}
```
3. 指向函数的指针：函数指针
```C++
#include <iostream>
using namespace std;

int add(int a, int b){
    return a + b;
}

int main(void)
{
    int (*fun_p)(int, int);
    fun_p = add;
    cout << fun_p(1, 6) << endl;
    return 0;
}
```
4. 指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。<br>
特别注意：定义指向成员函数的指针时，要标明指针所属的类。<br>
```C++
#include <iostream>

using namespace std;

class A
{
public:
    int var1, var2; 
    int add(){
        return var1 + var2;
    }
};

int main()
{
    A ex;
    ex.var1 = 3;
    ex.var2 = 4;
    int *p = &ex.var1; // 指向对象成员变量的指针
    cout << *p << endl;

    int (A::*fun_p)();
    fun_p = A::add; // 指向对象成员函数的指针 fun_p
    cout << (ex.*fun_p)() << endl;
    return 0;
}
```
5. this 指针：指向类的当前对象的指针常量。
```C++

#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    void set_name(string tmp)
    {
        this->name = tmp;
    }
    void set_age(int tmp)
    {
        this->age = age;
    }
    void set_sex(int tmp)
    {
        this->sex = tmp;
    }
    void show()
    {
        cout << "Name: " << this->name << endl;
        cout << "Age: " << this->age << endl;
        cout << "Sex: " << this->sex << endl;
    }

private:
    string name;
    int age;
    int sex;
};

int main()
{
    A *p = new A();
    p->set_name("Alice");
    p->set_age(16);
    p->set_sex(1);
    p->show();

    return 0;
}
```

[返回目录](#head)<br>


<div id="wild_ptr_hang_ptr"></div><br>

## 什么是野指针和悬空指针？
悬空指针：

若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。
举例：

```C++
void *p = malloc(size);
free(p); 
// 此时，p 指向的内存空间已释放， p 就是悬空指针。
```
野指针：

“野指针”是指不确定其指向的指针，未初始化的指针为“野指针”。

```C++
void *p; 
// 此时 p 是“野指针”。
```

[返回目录](#head)<br>

<div id="nullptr"></div><br>

## C++ 11 nullptr 比 NULL 优势
NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 #define NULL 0。<br>
nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。<br>
nullptr 的优势：
1. 有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。
2. 函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。
```C++
#include <iostream>
#include <cstring>
using namespace std;

void fun(char const *p)
{
    cout << "fun(char const *p)" << endl;
}

void fun(int tmp)
{
    cout << "fun(int tmp)" << endl;
}

int main()
{
    fun(nullptr); // fun(char const *p)
    /*
    fun(NULL); // error: call of overloaded 'fun(NULL)' is ambiguous
    */
    return 0;
}
```

[返回目录](#head)<br>


<div id="ptr_quote"></div><br>

## 指针和引用的区别？
* 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）
* 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）
* 指针可以为空，但是引用必须绑定对象。（是否可为空）
* 指针可以有多级，但是引用只能一级。（是否能为多级）

[返回目录](#head)<br>

<div id="const"></div><br>

## 常量指针和指针常量的区别
**常量指针：**<br>
常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br>
特点：const 的位置在指针声明运算符 * 的左侧。只要 const 位于 * 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）

```C++
const int * p;
int const * p;
```
注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。
例如：

```C++
#include <iostream>
using namespace std;

int main()
{
    const int c_var = 8;
    const int *p = &c_var; 
    *p = 6;            // error: assignment of read-only location '* p'
    return 0;
}
```
注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。
例如：

```C++
#include <iostream>
using namespace std;

int main()
{
    const int c_var1 = 8;
    const int c_var2 = 8;
    const int *p = &c_var1; 
    p = &c_var2;
    return 0;
}
```
**指针常量：**<br>
指针常量的本质上是个常量，只不过这个常量的值是一个指针。<br>
特点：const 位于指针声明操作符右侧，表明该对象本身是一个常量，* 左侧表示该指针指向的类型，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。

```C++
const int var;
int * const c_p = &var; 
```
注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。

```C++
#include <iostream>
using namespace std;

int main()
{
    int var, var1;
    int * const c_p = &var;
    c_p = &var1; // error: assignment of read-only variable 'c_p'
    return 0;
}
```
注意 2：指针的内容可以改变。

```C++
#include <iostream>
using namespace std;

int main()
{
    int var = 3;
    int * const c_p = &var;
    *c_p = 12; 
    return 0;
}
```

[返回目录](#head)<br>


<div id="func_ptr_func"></div><br>

## 函数指针和指针函数的区别


[返回目录](#head)<br>

<div id="force"></div><br>

## 强制类型转换有哪几种？

[返回目录](#head)<br>

<div id="struct_equal"></div><br>

## 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？

[返回目录](#head)<br>

<div id="parameter"></div><br>

## 参数传递时，值传递、引用传递、指针传递的区别？

[返回目录](#head)<br>

<div id="template"></div><br>

## 什么是模板？如何实现？

[返回目录](#head)<br>

<div id="diff_func_class_template"></div><br>

## 函数模板和类模板的区别？

[返回目录](#head)<br>

<div id="variable_template"></div><br>

## 什么是可变参数模板？

[返回目录](#head)<br>

<div id="template_specialty"></div><br>

## 什么是模板特化？为什么特化？

[返回目录](#head)<br>

<div id="include"></div><br>

## include " " 和 <> 的区别

[返回目录](#head)<br>

<div id="switch"></div><br>

## switch 的 case 里为何不能定义变量

[返回目录](#head)<br>

<div id="iterator"></div><br>

## 迭代器的作用？

[返回目录](#head)<br>

<div id="generic"></div><br>

## 泛型编程如何实现？

[返回目录](#head)<br>

<div id="type_extraction"></div><br>

## 什么是类型萃取？

[返回目录](#head)<br>

